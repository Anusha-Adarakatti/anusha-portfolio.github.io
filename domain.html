<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Amazon Business Cases - Anusha</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        :root {
            --amazon-orange: #FF9900;
            --amazon-dark: #232F3E;
            --amazon-light: #F2F3F3;
            --amazon-text: #131A22;
        }
        
        body {
            font-family: 'Inter', 'Roboto', Arial, sans-serif;
            margin: 0;
            padding: 0;
            color: var(--amazon-text);
            background-color: white;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }
        
        /* New Navbar Styles */
        .navbar {
            background-color: var(--amazon-dark);
            color: white;
            padding: 15px 0;
            position: sticky;
            top: 0;
            z-index: 100;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .nav-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }
        
        .logo {
            font-size: 24px;
            font-weight: 700;
            color: white;
            text-decoration: none;
        }
        
        .nav-links {
            display: flex;
            list-style: none;
            margin: 0;
            padding: 0;
        }
        
        .nav-links li {
            margin-left: 25px;
        }
        
        .nav-links a {
            color: white;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s;
        }
        
        .nav-links a:hover {
            color: var(--amazon-orange);
        }
        
        .tagline {
            font-style: italic;
            opacity: 0.9;
            text-align: center;
            margin: 20px 0;
        }
        
        h1, h2, h3, h4 {
            color: var(--amazon-dark);
        }
        
        h2 {
            border-bottom: 2px solid var(--amazon-orange);
            padding-bottom: 8px;
            margin-top: 40px;
        }
        
        h3 {
            margin-top: 30px;
            color: var(--amazon-orange);
        }
        
        .intro-section {
            background-color: var(--amazon-light);
            padding: 25px;
            border-radius: 5px;
            margin-bottom: 30px;
        }
        
        .business-case {
            background-color: white;
            border: 1px solid #ddd;
            border-radius: 5px;
            padding: 25px;
            margin-bottom: 30px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        
        .case-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .case-number {
            background-color: var(--amazon-orange);
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .case-title {
            font-size: 24px;
            font-weight: 600;
            color: var(--amazon-dark);
            margin: 0;
        }
        
        .challenge-list {
            background-color: #f8f9fa;
            padding: 15px 20px;
            border-left: 4px solid var(--amazon-orange);
            margin: 20px 0;
        }
        
        .challenge-list li {
            margin-bottom: 8px;
        }
        
        .algorithm-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .algorithm-table th {
            background-color: var(--amazon-dark);
            color: white;
            padding: 12px;
            text-align: left;
        }
        
        .algorithm-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .algorithm-table tr:nth-child(even) {
            background-color: #f9f9f9;
        }
        
        .efficiency-table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        
        .efficiency-table th {
            background-color: var(--amazon-orange);
            color: white;
            padding: 12px;
            text-align: left;
        }
        
        .efficiency-table td {
            padding: 10px 12px;
            border-bottom: 1px solid #ddd;
        }
        
        .efficiency-table tr:nth-child(even) {
            background-color: #fff9f0;
        }
        
        .conceptual-model {
            text-align: center;
            margin: 30px 0;
            padding: 20px;
            background-color: var(--amazon-light);
            border-radius: 5px;
        }
        
        .conceptual-model img {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
        }
        
        .model-caption {
            margin-top: 10px;
            font-style: italic;
            color: #666;
        }
        
        .code-section {
            margin: 25px 0;
        }
        
        .code-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            background-color: var(--amazon-dark);
            color: white;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
        }
        
        .code-header:hover {
            background-color: #1a2431;
        }
        
        .code-title {
            font-weight: 500;
            margin: 0;
            color: #e68a00;
        }
        
        .toggle-code {
            font-size: 14px;
            color: var(--amazon-orange);
        }
        
        .code-content {
            display: none;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 5px 5px;
            padding: 15px;
            overflow-x: auto;
        }
        
        pre {
            margin: 0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.4;
            color: #333;
        }
        
        .inferences {
            background-color: #f0f7ff;
            padding: 20px;
            border-left: 4px solid var(--amazon-orange);
            margin: 25px 0;
        }
        
        .inferences h4 {
            margin-top: 0;
            color: var(--amazon-dark);
        }
        
        .references {
            font-size: 14px;
            color: #666;
            margin-top: 40px;
        }
        
        .references h3 {
            font-size: 18px;
            margin-bottom: 10px;
        }
        
        .references ul {
            padding-left: 20px;
        }
        
        .objectives-list {
            list-style-type: none;
            padding-left: 0;
        }
        
        .objectives-list li {
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="%23FF9900"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>') no-repeat left center;
            padding-left: 30px;
            margin-bottom: 15px;
            min-height: 24px;
        }
        
        .nav-buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 40px;
        }
        
        .nav-button {
            background-color: var(--amazon-orange);
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-weight: 500;
            text-decoration: none;
            transition: background-color 0.3s;
        }
        
        .nav-button:hover {
            background-color: #e68a00;
        }
        
        /* New Footer Styles */
        .connect-footer {
            background-color: var(--amazon-dark);
            color: white;
            text-align: center;
            padding: 40px 20px;
            margin-top: 50px;
        }
        
        .footer-heading {
            font-size: 28px;
            margin-bottom: 10px;
            color: white;
        }
        
        .footer-subtext {
            font-size: 16px;
            margin-bottom: 25px;
            opacity: 0.9;
        }
        
        .social-footer-icons {
            display: flex;
            justify-content: center;
            gap: 20px;
        }
        
        .social-footer-icons a {
            color: white;
            font-size: 24px;
            transition: color 0.3s;
        }
        
        .social-footer-icons a:hover {
            color: var(--amazon-orange);
        }
        
        @media (max-width: 768px) {
            .nav-container {
                flex-direction: column;
            }
            
            .logo {
                margin-bottom: 15px;
            }
            
            .nav-links {
                flex-wrap: wrap;
                justify-content: center;
            }
            
            .nav-links li {
                margin: 5px 10px;
            }
            
            .case-header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .case-number {
                margin-bottom: 10px;
            }
        }
    </style>
</head>
<body>
    <header class="navbar">
        <div class="nav-container">
            <h1 class="logo">Anusha</h1>
            <nav>
                <ul class="nav-links">
                    <li><a href="index.html">Home</a></li>
                    <li><a href="index.html#about">About Me</a></li>
                    <li><a href="index.html#projects">Projects</a></li>
                    <li><a href="index.html#domain">Domain</a></li>
                    <li><a href="#connect">Contact</a></li>
                </ul>
            </nav>
        </div>
    </header>
    
    <div class="container">
        <div class="tagline">Bridging Algorithmic Theory with Amazon's Operational Challenges</div>
        
        <section class="intro-section">
            <h2>Introduction</h2>
            <p>My domain of interest is Amazon, a global leader in e-commerce and technology, known for its complex and large-scale operations. Amazon's business involves challenges like optimizing logistics, managing vast inventories, and processing massive real-time data—all requiring highly efficient, scalable, and reliable systems.</p>
            
            <p>Through my academic studies in computer science, I have built a strong foundation in algorithms, data structures, and system design. I am focused on applying these concepts directly to Amazon's real-world business cases. By using graph algorithms, dynamic programming, greedy methods, and efficient data structures, I aim to design solutions that improve Amazon's operational efficiency and scalability.</p>
            
            <p>This portfolio demonstrates how my theoretical knowledge can be applied to solve practical challenges faced by Amazon, bridging academic learning with industry needs.</p>
        </section>
        
        <section>
            <h2>Objectives</h2>
            <ul class="objectives-list">
                <li><strong>Analyze Amazon's Business Challenges</strong><br>Understand the core operational problems Amazon faces in logistics, inventory management, and data processing.</li>
                <li><strong>Map Algorithms and Data Structures to Real Problems</strong><br>Apply appropriate algorithmic techniques—such as graph traversal, dynamic programming, greedy algorithms, and efficient data structures—to model and solve these challenges.</li>
                <li><strong>Design Efficient and Scalable Solutions</strong><br>Develop system designs and algorithmic solutions that optimize performance, reduce time and space complexity, and scale to Amazon's massive data and user base.</li>
                <li><strong>Perform Complexity and Impact Analysis</strong><br>Evaluate the runtime and space efficiency of solutions, ensuring they meet real-world demands and improve Amazon's business operations.</li>
                <li><strong>Bridge Theory and Industry Practice</strong><br>Demonstrate how academic knowledge in algorithms and DSA translates to practical applications within Amazon's technological ecosystem.</li>
            </ul>
        </section>
        
        <!-- Business Case 1 -->
        <section class="business-case">
            <div class="case-header">
                <div class="case-number">Business Case 1</div>
                <h2 class="case-title">Optimizing Last-Mile Delivery Routes</h2>
            </div>
            
            <h3>Introduction</h3>
            <p><strong>Why this matters:</strong><br>
            Amazon delivers billions of packages annually. The last-mile delivery phase — getting packages from local delivery stations to customers — is the most complex and costly part of the supply chain.</p>
            
            <div class="challenge-list">
                <strong>Challenges include:</strong>
                <ul>
                    <li>Highly dynamic urban traffic</li>
                    <li>Variable delivery addresses</li>
                    <li>Tight delivery time windows</li>
                    <li>Fleet constraints (driver availability, vehicle capacity)</li>
                </ul>
            </div>
            
            <p>Optimizing delivery routes reduces costs, improves customer experience (on-time delivery), and minimizes carbon footprint — directly impacting Amazon's bottom line and sustainability goals.</p>
            
            <h3>Business Case Identified</h3>
            <p><strong>Problem Statement</strong><br>
            Amazon operates a vast fleet of delivery vans and drivers that must deliver hundreds of thousands of packages daily.<br>
            The goal is to:</p>
            
            <ul>
                <li>Assign delivery stops to drivers</li>
                <li>Generate optimized routes for each driver</li>
                <li>Minimize total distance & time</li>
                <li>Satisfy delivery time windows</li>
                <li>Adapt to real-world changes (traffic, delays)</li>
            </ul>
            
            <p><strong>Objective</strong><br>
            Design an algorithmic routing engine that:</p>
            
            <ul>
                <li>Computes efficient delivery tours (vehicle routes)</li>
                <li>Assigns packages optimally across drivers</li>
                <li>Responds dynamically to real-time traffic data</li>
                <li>Scales to large delivery regions (thousands of stops)</li>
            </ul>
            
            <h3>Algorithms & Data Structures Used</h3>
            <p>The problem maps to a Vehicle Routing Problem with Time Windows (VRPTW) — a classic combinatorial optimization problem.</p>
            
            <h4>Core Algorithms and DS Applied</h4>
            <table class="algorithm-table">
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Application</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Graph Representation</td>
                        <td>Road network as weighted graph (nodes = delivery stops, edges = travel time)</td>
                    </tr>
                    <tr>
                        <td>Dijkstra's Algorithm</td>
                        <td>Fast shortest path computation between stops</td>
                    </tr>
                    <tr>
                        <td>Clarke-Wright Savings Heuristic</td>
                        <td>Initial route construction (merge routes with high savings)</td>
                    </tr>
                    <tr>
                        <td>2-opt Local Search</td>
                        <td>Optimize individual routes by swapping edges</td>
                    </tr>
                    <tr>
                        <td>Simulated Annealing</td>
                        <td>Global optimization with escape from local optima</td>
                    </tr>
                    <tr>
                        <td>Priority Queues</td>
                        <td>Efficient Dijkstra implementation</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="conceptual-model">
                <h3>Conceptual Model Diagram</h3>
                <img src="ChatGPT Image Jun 6, 2025, 05_27_28 PM.png" 
       alt="Amazon Route Optimization System"
       style="width: 600px; height: 600px; object-fit: cover; border: 1px solid #FF9900;">
            </div>
            
            <h3>C++ Algorithmic Implementation</h3>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode('code1')">
                    <h4 class="code-title">Graph & Dijkstra's Algorithm</h4>
                    <span class="toggle-code">Show Implementation</span>
                </div>
                <div class="code-content" id="code1">
                    <pre>
#include &lt;queue&gt;
#include &lt;vector&gt;
#include &lt;cmath&gt;
#include &lt;iostream&gt;

using namespace std;

const int MAX_NODES = 1000;
const double INF = 1e9;

struct Edge {
    int to;
    double weight;
};

vector&lt;Edge&gt; graph[MAX_NODES];
double dist[MAX_NODES];

void dijkstra(int source) {
    priority_queue&lt;pair&lt;double, int&gt;, vector&lt;pair&lt;double, int&gt;&gt;, greater&lt;pair&lt;double, int&gt;&gt;&gt; pq;
    
    for (int i = 0; i &lt; MAX_NODES; ++i)
        dist[i] = INF;
    
    dist[source] = 0.0;
    pq.push({0.0, source});
    
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        
        if (d &gt; dist[u]) continue;
        
        for (auto e : graph[u]) {
            if (dist[e.to] &gt; dist[u] + e.weight) {
                dist[e.to] = dist[u] + e.weight;
                pq.push({dist[e.to], e.to});
            }
        }
    }
}</pre>
                </div>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode('code2')">
                    <h4 class="code-title">Simple 2-opt for Tour Optimization</h4>
                    <span class="toggle-code">Show Implementation</span>
                </div>
                <div class="code-content" id="code2">
                    <pre>
void two_opt(vector&lt;int&gt;& tour, vector&lt;vector&lt;double&gt;&gt;& cost) {
    bool improved = true;
    while (improved) {
        improved = false;
        for (int i = 1; i &lt; tour.size() - 2; ++i) {
            for (int j = i + 1; j &lt; tour.size() - 1; ++j) {
                double delta = cost[tour[i-1]][tour[j]] + cost[tour[i]][tour[j+1]]
                             - cost[tour[i-1]][tour[i]] - cost[tour[j]][tour[j+1]];
                
                if (delta &lt; -1e-6) {
                    reverse(tour.begin() + i, tour.begin() + j + 1);
                    improved = true;
                }
            }
        }
    }
}</pre>
                </div>
            </div>
            
            <h3>Efficiency Analysis</h3>
            <table class="efficiency-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Practical Suitability</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Dijkstra</td>
                        <td>O(E + V log V)</td>
                        <td>Fast single-source shortest path</td>
                    </tr>
                    <tr>
                        <td>Clarke-Wright</td>
                        <td>O(N² log N)</td>
                        <td>Good heuristic for initial VRPTW solution</td>
                    </tr>
                    <tr>
                        <td>2-opt</td>
                        <td>O(N²) per iteration</td>
                        <td>Local improvement of single route</td>
                    </tr>
                    <tr>
                        <td>Simulated Annealing</td>
                        <td>Varies</td>
                        <td>Escape local optima, global improvement</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="inferences">
                <h4>Observations:</h4>
                <ul>
                    <li>Exact VRPTW is NP-hard; heuristics are essential for real-time scalability.</li>
                    <li>Combining Clarke-Wright + 2-opt + Simulated Annealing achieves good quality in practice.</li>
                    <li>Priority Queues accelerate Dijkstra runs for pairwise cost matrix.</li>
                </ul>
                
                <h4>Inferences</h4>
                <ul>
                    <li>Optimizing last-mile delivery is a core real-world example of graph algorithms, heuristics, and metaheuristics.</li>
                    <li>Balancing speed vs. optimality is key in production-scale routing.</li>
                    <li>Combining multiple algorithmic layers yields high performance:
                        <ul>
                            <li>Graph search for travel times</li>
                            <li>Savings-based merging for initial clustering</li>
                            <li>2-opt and metaheuristics for fine-grained optimization</li>
                        </ul>
                    </li>
                </ul>
                
                <h4>Future directions:</h4>
                <ul>
                    <li>Dynamic traffic-aware routing (real-time adjustments)</li>
                    <li>Learning-based approaches to improve heuristic quality over time</li>
                </ul>
            </div>
            
            <div class="references">
                <h3>References</h3>
                <ul>
                    <li>Clarke, G. & Wright, J. Scheduling of Vehicles from a Central Depot to a Number of Delivery Points.</li>
                    <li>Golden et al. The VRP Handbook.</li>
                    <li>Dijkstra, E. A Note on Two Problems in Connexion with Graphs.</li>
                    <li>Amazon Last Mile Science: https://www.amazon.science</li>
                </ul>
            </div>
        </section>
        
        <!-- Business Case 2 -->
        <section class="business-case">
            <div class="case-header">
                <div class="case-number">Business Case 2</div>
                <h2 class="case-title">Warehouse Robotics Path Planning</h2>
            </div>
            
            <h3>Introduction</h3>
            <p><strong>Why this matters:</strong><br>
            Amazon's fulfillment centers deploy thousands of autonomous mobile robots (AMRs) to move inventory shelves (pods) to and from human packers.</p>
            
            <p>Efficient path planning for these robots is critical because:</p>
            
            <div class="challenge-list">
                <ul>
                    <li>Collisions can cause costly downtime</li>
                    <li>Suboptimal paths waste time and energy</li>
                    <li>The environment is dynamic — obstacles can appear suddenly</li>
                    <li>Many robots operate simultaneously in a dense space</li>
                </ul>
            </div>
            
            <p>Optimizing robot paths ensures:</p>
            <ul>
                <li>Faster order processing</li>
                <li>Higher throughput</li>
                <li>Better utilization of warehouse floor space</li>
                <li>Safer operation</li>
            </ul>
            
            <h3>Business Case Identified</h3>
            <p><strong>Problem Statement</strong><br>
            Design an algorithmic path planning engine that:</p>
            
            <ul>
                <li>Computes safe, efficient paths for all robots</li>
                <li>Avoids collisions in space and time (not just space)</li>
                <li>Re-plans dynamically if the environment changes</li>
                <li>Scales to hundreds of robots operating in parallel</li>
            </ul>
            
            <p><strong>Objective</strong><br>
            Implement a scalable multi-robot path planning system using:</p>
            
            <ul>
                <li>Graph-based search</li>
                <li>Space-time reservation tables</li>
                <li>Local and global optimization heuristics</li>
                <li>Conflict-aware coordination mechanisms</li>
            </ul>
            
            <h3>Algorithms & Data Structures Used</h3>
            <table class="algorithm-table">
                <thead>
                    <tr>
                        <th>Concept</th>
                        <th>Application</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Grid Graph</td>
                        <td>Represent warehouse floor as 2D grid graph</td>
                    </tr>
                    <tr>
                        <td>A* Search Algorithm</td>
                        <td>Compute shortest path for each robot</td>
                    </tr>
                    <tr>
                        <td>Space-Time Reservation Table</td>
                        <td>Track robot occupancy over time</td>
                    </tr>
                    <tr>
                        <td>Priority Queue</td>
                        <td>Efficient A* open list management</td>
                    </tr>
                    <tr>
                        <td>Dynamic Replanning</td>
                        <td>Handle unexpected obstacles</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="conceptual-model">
                <h3>Conceptual Model Diagram</h3>
                <img src="ChatGPT Image Jun 6, 2025, 05_36_38 PM.png" 
       alt="Amazon Route Optimization System"
       style="width: 600px; height: 600px; object-fit: cover; border: 1px solid #FF9900;">
            </div>
            
            <h3>C++ Algorithmic Implementation</h3>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode('code3')">
                    <h4 class="code-title">Grid Graph and Node Structure</h4>
                    <span class="toggle-code">Show Implementation</span>
                </div>
                <div class="code-content" id="code3">
                    <pre>
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;queue&gt;
#include &lt;map&gt;
#include &lt;set&gt;
#include &lt;cmath&gt;
#include &lt;algorithm&gt;

using namespace std;

const int ROWS = 6;
const int COLS = 6;

struct Node {
    int x, y;
    Node(int x_=0, int y_=0) : x(x_), y(y_) {}
    
    bool operator==(const Node& other) const {
        return x == other.x && y == other.y;
    }
    
    bool operator&lt;(const Node& other) const {
        return tie(x, y) &lt; tie(other.x, other.y);
    }
};</pre>
                </div>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode('code4')">
                    <h4 class="code-title">A* with Space-Time Reservation Table</h4>
                    <span class="toggle-code">Show Implementation</span>
                </div>
                <div class="code-content" id="code4">
                    <pre>
int heuristic(const Node& a, const Node& b) {
    return abs(a.x - b.x) + abs(a.y - b.y);
}

map&lt;pair&lt;Node, int&gt;, bool&gt; reservationTable;

vector&lt;Node&gt; a_star_search(const Node& start, const Node& goal) {
    typedef pair&lt;int, pair&lt;Node, int&gt;&gt; PQElement; 
    priority_queue&lt;PQElement, vector&lt;PQElement&gt;, greater&lt;PQElement&gt;&gt; frontier;
    
    map&lt;pair&lt;Node, int&gt;, Node&gt; came_from;
    map&lt;pair&lt;Node, int&gt;, int&gt; cost_so_far;
    
    frontier.push({0, {start, 0}});
    came_from[{start, 0}] = start;
    cost_so_far[{start, 0}] = 0;
    
    while (!frontier.empty()) {
        auto current_pair = frontier.top(); frontier.pop();
        Node current = current_pair.second.first;
        int time = current_pair.second.second;
        
        if (current == goal) {
            vector&lt;Node&gt; path;
            pair&lt;Node, int&gt; curr = {current, time};
            while (!(came_from[curr] == curr.first && curr.second == 0)) {
                path.push_back(curr.first);
                curr = {came_from[curr], curr.second - 1};
            }
            path.push_back(start);
            reverse(path.begin(), path.end());
            return path;
        }
        
        vector&lt;Node&gt; neighbors = {
            Node(current.x + 1, current.y),
            Node(current.x - 1, current.y),
            Node(current.x, current.y + 1),
            Node(current.x, current.y - 1)
        };
        
        for (auto& next : neighbors) {
            if (next.x &lt; 0 || next.y &lt; 0 || next.x &gt;= ROWS || next.y &gt;= COLS)
                continue;
            
            int new_cost = cost_so_far[{current, time}] + 1;
            
            if (reservationTable[{next, time + 1}])
                continue;
            
            if (cost_so_far.find({next, time + 1}) == cost_so_far.end() ||
                new_cost &lt; cost_so_far[{next, time + 1}]) {
                
                cost_so_far[{next, time + 1}] = new_cost;
                int priority = new_cost + heuristic(next, goal);
                frontier.push({priority, {next, time + 1}});
                came_from[{next, time + 1}] = current;
            }
        }
    }
    
    return {};
}</pre>
                </div>
            </div>
            
            <div class="code-section">
                <div class="code-header" onclick="toggleCode('code5')">
                    <h4 class="code-title">Example Usage</h4>
                    <span class="toggle-code">Show Implementation</span>
                </div>
                <div class="code-content" id="code5">
                    <pre>
int main() {
    Node start(0, 0);
    Node goal(5, 5);
    
    reservationTable[{Node(3, 3), 4}] = true; // Example dynamic obstacle
    
    vector&lt;Node&gt; path = a_star_search(start, goal);
    
    if (path.empty()) {
        cout &lt;&lt; "No path found!" &lt;&lt; endl;
    } else {
        cout &lt;&lt; "Path found:" &lt;&lt; endl;
        for (auto& n : path) {
            cout &lt;&lt; "(" &lt;&lt; n.x &lt;&lt; ", " &lt;&lt; n.y &lt;&lt; ") ";
        }
        cout &lt;&lt; endl;
    }
    
    return 0;
}</pre>
                </div>
            </div>
            
            <h3>Efficiency Analysis</h3>
            <table class="efficiency-table">
                <thead>
                    <tr>
                        <th>Algorithm</th>
                        <th>Time Complexity</th>
                        <th>Practical Suitability</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>A* Search</td>
                        <td>O(E + V log V)</td>
                        <td>Efficient single-robot path planning</td>
                    </tr>
                    <tr>
                        <td>Space-Time Reservation Table</td>
                        <td>O(1) lookup per cell/time</td>
                        <td>Fast collision checks</td>
                    </tr>
                    <tr>
                        <td>Dynamic Replanning</td>
                        <td>Same as A*</td>
                        <td>Flexible handling of obstacles</td>
                    </tr>
                    <tr>
                        <td>Conflict-Based Search (CBS)</td>
                        <td>Exponential worst-case</td>
                        <td>Practical multi-robot coordination</td>
                    </tr>
                </tbody>
            </table>
            
            <div class="inferences">
                <h4>Observations:</h4>
                <ul>
                    <li>Space-time reservation ensures safety → robots do not collide.</li>
                    <li>Dynamic replanning allows graceful handling of unexpected events.</li>
                    <li>CBS can be layered on top to achieve global coordination.</li>
                </ul>
                
                <h4>Inferences</h4>
                <ul>
                    <li>Path planning in dynamic, dense environments is a natural application of graph search and reservation-based coordination.</li>
                    <li>A simple space-time A* is already very effective and fast for production use.</li>
                    <li>For large fleets (hundreds of robots), CBS or prioritized planning becomes necessary.</li>
                </ul>
                
                <h4>Future directions:</h4>
                <ul>
                    <li>Optimize reservation table (compact representations)</li>
                    <li>Parallelize path planning</li>
                    <li>Integrate machine learning to predict congestion areas</li>
                </ul>
            </div>
            
            <div class="references">
                <h3>References</h3>
                <ul>
                    <li>Silver, D. Cooperative Pathfinding.</li>
                    <li>Standley, T. Optimal Multi-Agent Pathfinding Using CBS.</li>
                    <li>Amazon Robotics: https://www.amazonrobotics.com</li>
                </ul>
            </div>
        </section>

        <!-- Business Case 3 -->
<section class="business-case">
    <div class="case-header">
        <div class="case-number">Business Case 3</div>
        <h2 class="case-title">Personalized Product Recommendations Using Search Trees</h2>
    </div>
    
    <h3>Introduction</h3>
    <p><strong>Why this matters:</strong><br>
    Amazon offers millions of products across thousands of categories. Providing personalized recommendations is critical to:</p>
    
    <div class="challenge-list">
        <ul>
            <li>Boost sales and cross-selling</li>
            <li>Increase customer engagement</li>
            <li>Improve shopping experience and loyalty</li>
        </ul>
    </div>
    
    <p>While machine learning models are often used at scale, at the core of many fast-serving recommendation engines lie well-designed search trees and optimized data structures that:</p>
    <ul>
        <li>Enable fast retrieval of related products</li>
        <li>Support real-time personalization</li>
        <li>Scale to very large product catalogs</li>
    </ul>
    
    <h3>Business Case Identified</h3>
    <p><strong>Problem Statement</strong><br>
    Design an algorithmic recommendation engine that:</p>
    
    <ul>
        <li>Indexes products based on category, tags, attributes</li>
        <li>Supports fast traversal and retrieval of related products</li>
        <li>Matches user preferences and interaction history</li>
        <li>Serves recommendations in real-time</li>
    </ul>
    
    <p><strong>Objective</strong><br>
    Implement a Search Tree-based Recommendation Engine using:</p>
    
    <ul>
        <li>Balanced Trees (e.g. AVL/Red-Black) for indexing</li>
        <li>Trie structures for prefix-based lookup</li>
        <li>User-Product interaction mapping</li>
        <li>Efficient algorithms for top-N recommendation ranking</li>
    </ul>
    
    <h3>Algorithms & Data Structures Used</h3>
    <table class="algorithm-table">
        <thead>
            <tr>
                <th>Concept</th>
                <th>Application</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>Balanced Search Trees (AVL, Red-Black)</td>
                <td>Index products by popularity, rating, category</td>
            </tr>
            <tr>
                <td>Trie (Prefix Tree)</td>
                <td>Support fast prefix/product name search</td>
            </tr>
            <tr>
                <td>Inverted Index</td>
                <td>Map product tags to product IDs</td>
            </tr>
            <tr>
                <td>Hash Maps</td>
                <td>Map user → product interaction history</td>
            </tr>
            <tr>
                <td>Priority Queue / Heap</td>
                <td>Rank top-N recommendations dynamically</td>
            </tr>
            <tr>
                <td>DFS / BFS</td>
                <td>Tree traversal for recommendation expansion</td>
            </tr>
        </tbody>
    </table>
    
    <div class="conceptual-model">
        <h3>Conceptual Model Diagram</h3>
        <img src="ChatGPT Image Jun 6, 2025, 06_16_54 PM.png" 
             alt="Amazon Recommendation System Architecture"
             style="width: 600px; height: 400px; object-fit: contain; border-left: 4px solid #FF9900; padding: 10px;">
        
    </div>
    
    <!-- <div class="conceptual-model">
        <h3>Product Search Tree Example</h3>
        <img src="product_search_tree.png" 
             alt="Product Category Search Tree"
             style="width: 500px; height: 350px; object-fit: contain; border: 1px solid #E6E6E6; margin: 20px auto; display: block;">
    </div> -->
    
    <h3>C++ Algorithmic Implementation</h3>
    
    <div class="code-section">
        <div class="code-header" onclick="toggleCode('code6')">
            <h4 class="code-title">Balanced Search Tree (AVL) for Product Indexing</h4>
            <span class="toggle-code">Show Implementation</span>
        </div>
        <div class="code-content" id="code6">
            <pre>
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
#include &lt;string&gt;
using namespace std;

struct Product {
    int id;
    string name;
    int popularity; // Higher is better
    Product(int id_, string name_, int pop_) : id(id_), name(name_), popularity(pop_) {}
};

struct AVLNode {
    Product prod;
    AVLNode *left, *right;
    int height;
    
    AVLNode(Product p) : prod(p), left(nullptr), right(nullptr), height(1) {}
};

int height(AVLNode* node) {
    return node ? node->height : 0;
}

int balanceFactor(AVLNode* node) {
    return height(node->left) - height(node->right);
}

AVLNode* rightRotate(AVLNode* y) {
    AVLNode* x = y->left;
    AVLNode* T2 = x->right;
    
    x->right = y;
    y->left = T2;
    
    y->height = 1 + max(height(y->left), height(y->right));
    x->height = 1 + max(height(x->left), height(x->right));
    
    return x;
}

AVLNode* leftRotate(AVLNode* x) {
    AVLNode* y = x->right;
    AVLNode* T2 = y->left;
    
    y->left = x;
    x->right = T2;
    
    x->height = 1 + max(height(x->left), height(x->right));
    y->height = 1 + max(height(y->left), height(y->right));
    
    return y;
}

AVLNode* insert(AVLNode* node, Product prod) {
    if (!node) return new AVLNode(prod);
    
    if (prod.popularity > node->prod.popularity)
        node->left = insert(node->left, prod);
    else
        node->right = insert(node->right, prod);
    
    node->height = 1 + max(height(node->left), height(node->right));
    
    int bf = balanceFactor(node);
    
    // Left Left
    if (bf > 1 && prod.popularity > node->left->prod.popularity)
        return rightRotate(node);
    
    // Right Right
    if (bf < -1 && prod.popularity <= node->right->prod.popularity)
        return leftRotate(node);
    
    // Left Right
    if (bf > 1 && prod.popularity <= node->left->prod.popularity) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    
    // Right Left
    if (bf < -1 && prod.popularity > node->right->prod.popularity) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }
    
    return node;
}</pre>
        </div>
    </div>
    
    <div class="code-section">
        <div class="code-header" onclick="toggleCode('code7')">
            <h4 class="code-title">Trie for Fast Prefix Search</h4>
            <span class="toggle-code">Show Implementation</span>
        </div>
        <div class="code-content" id="code7">
            <pre>
struct TrieNode {
    map&lt;char, TrieNode*&gt; children;
    bool isEndOfWord;
    vector&lt;int&gt; productIds; // Products matching this prefix
    
    TrieNode() : isEndOfWord(false) {}
};

void insertTrie(TrieNode* root, const string& word, int productId) {
    TrieNode* node = root;
    for (char ch : word) {
        if (!node->children[ch])
            node->children[ch] = new TrieNode();
        node = node->children[ch];
    }
    node->isEndOfWord = true;
    node->productIds.push_back(productId);
}

vector&lt;int&gt; searchPrefix(TrieNode* root, const string& prefix) {
    TrieNode* node = root;
    for (char ch : prefix) {
        if (!node->children[ch])
            return {};
        node = node->children[ch];
    }
    return node->productIds;
}</pre>
        </div>
    </div>
    
    <div class="code-section">
        <div class="code-header" onclick="toggleCode('code8')">
            <h4 class="code-title">Example Usage</h4>
            <span class="toggle-code">Show Implementation</span>
        </div>
        <div class="code-content" id="code8">
            <pre>
int main() {
    // Product AVL Tree
    AVLNode* root = nullptr;
    root = insert(root, Product(1, "iPhone", 90));
    root = insert(root, Product(2, "Samsung Galaxy", 85));
    root = insert(root, Product(3, "Dell Laptop", 75));
    
    // Product Trie
    TrieNode* trieRoot = new TrieNode();
    insertTrie(trieRoot, "iPhone", 1);
    insertTrie(trieRoot, "Samsung", 2);
    insertTrie(trieRoot, "Dell", 3);
    
    // Search prefix
    vector&lt;int&gt; matches = searchPrefix(trieRoot, "Sam");
    cout &lt;&lt; "Products matching 'Sam': ";
    for (int id : matches)
        cout &lt;&lt; id &lt;&lt; " ";
    cout &lt;&lt; endl;
    
    return 0;
}</pre>
        </div>
    </div>
    
    <h3>Efficiency Analysis</h3>
    <table class="efficiency-table">
        <thead>
            <tr>
                <th>Algorithm</th>
                <th>Time Complexity</th>
                <th>Practical Suitability</th>
            </tr>
        </thead>
        <tbody>
            <tr>
                <td>AVL Insert/Search</td>
                <td>O(log N)</td>
                <td>Fast insert/search by popularity</td>
            </tr>
            <tr>
                <td>Trie Insert/Search</td>
                <td>O(W), W = length of word</td>
                <td>Very fast prefix search</td>
            </tr>
            <tr>
                <td>Hash Maps</td>
                <td>O(1) avg</td>
                <td>User-product interaction lookup</td>
            </tr>
            <tr>
                <td>Priority Queue (Heap)</td>
                <td>O(log K)</td>
                <td>Efficient top-N recommendation ranking</td>
            </tr>
        </tbody>
    </table>
    
    <div class="inferences">
        <h4>Observations:</h4>
        <ul>
            <li>Tries enable instant prefix-based product lookup</li>
            <li>AVL trees maintain a balanced popularity index</li>
            <li>Priority queues efficiently support dynamic top-N extraction</li>
        </ul>
        
        <h4>Inferences</h4>
        <ul>
            <li>Hybrid tree-based data structures are a natural fit for real-time recommendation engines</li>
            <li>Combining Trie (prefix search), AVL Tree (popularity index), and HashMap (user history) enables a full algorithmic pipeline</li>
            <li>This approach provides millisecond response times even for cold starts</li>
        </ul>
        
        <h4>Future directions:</h4>
        <ul>
            <li>Add user similarity scoring for collaborative filtering</li>
            <li>Optimize Trie space usage with compressed tries</li>
            <li>Parallelize tree traversals to scale to massive catalogs</li>
        </ul>
    </div>
    
    <div class="references">
        <h3>References</h3>
        <ul>
            <li>Cormen et al. Introduction to Algorithms</li>
            <li>Gusfield, D. Algorithms on Strings, Trees, and Sequences</li>
            <li>Amazon Personalization Science: https://www.amazon.science</li>
        </ul>
    </div>
</section>
        
        <div class="nav-buttons">
            <a href="#" class="nav-button">&larr; Previous Case</a>
            <a href="#" class="nav-button">Next Case &rarr;</a>
        </div>
    </div>
    
    <footer class="connect-footer" id="connect">
        <h2 class="footer-heading">Let's Connect</h2>
        <p class="footer-subtext">Feel free to reach out for collaborations or just a friendly hello 😊</p>
        <div class="social-footer-icons">
            <a href="mailto:anushaadarakatti47@gmail.com" target="_blank"><i class="fas fa-envelope"></i></a>
            <a href="https://www.linkedin.com/in/yourprofile" target="_blank"><i class="fab fa-linkedin"></i></a>
            <a href="https://github.com/yourprofile" target="_blank"><i class="fab fa-github"></i></a>
            <a href="https://twitter.com/yourprofile" target="_blank"><i class="fab fa-twitter"></i></a>
        </div>
    </footer>
    
    <script>
        function toggleCode(id) {
            const codeContent = document.getElementById(id);
            const toggleBtn = codeContent.previousElementSibling.querySelector('.toggle-code');
            
            if (codeContent.style.display === 'block') {
                codeContent.style.display = 'none';
                toggleBtn.textContent = 'Show Implementation';
            } else {
                codeContent.style.display = 'block';
                toggleBtn.textContent = 'Hide Implementation';
            }
        }
    </script>
</body>
</html>